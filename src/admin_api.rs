use std::{sync::Arc, time::Duration};

use k8s_openapi::api::core::v1::Secret;
use kube::{Api, ResourceExt};
use reqwest::header::{HeaderMap, HeaderValue, AUTHORIZATION};

use crate::{reconcilers::Context, resources::Garage, Error, Result};

use self::client::types::{LayoutVersion, NodeRoleChange, NodeRoleUpdate};

/// Autogenerated client for the garage admin API using its corresponding openapi spec.
mod client {
    #![allow(dead_code)]
    include!(concat!(env!("OUT_DIR"), "/garage-admin-client.rs"));
}

pub struct GarageAdmin<'a> {
    garage: &'a Garage,
    client: client::Client,
}

impl<'a> GarageAdmin<'a> {
    pub async fn try_from_garage(garage: &Garage, context: Arc<Context>) -> Result<GarageAdmin> {
        let token = {
            let default_name = garage.prefixed_name("admin.key");
            let admin_token_name = garage
                .spec
                .secrets
                .admin
                .as_ref()
                .and_then(|a| a.name.as_ref())
                .unwrap_or(&default_name);

            let secrets = Api::<Secret>::namespaced(
                context.client.clone(),
                &garage.namespace().ok_or(Error::IllegalGarage)?,
            );

            let secret = secrets
                .get(&admin_token_name)
                .await
                .map_err(Error::KubeError)?;
            let token = secret.data.ok_or(Error::IllegalGarage)?;
            let token = token.get("key").ok_or(Error::IllegalGarage)?;

            String::from_utf8(token.0.clone()).unwrap()
        };

        Ok(GarageAdmin::with_secret(&garage, &token)?)
    }

    pub fn with_secret(garage: &'a Garage, token: &str) -> Result<GarageAdmin<'a>> {
        // All requests must be authenticated using bearer auth
        let headers = {
            let mut headers = HeaderMap::new();
            let mut auth = HeaderValue::from_str(&format!("Bearer {token}")).unwrap();
            auth.set_sensitive(true);

            headers.insert(AUTHORIZATION, auth);
            headers
        };

        // Use a client to handle setting common request parameters
        // TODO: Handle error here nicely
        let client = reqwest::Client::builder()
            .connect_timeout(Duration::from_secs(5))
            .default_headers(headers)
            .build()
            .unwrap();

        let admin_port = garage.spec.config.ports.admin;
        let url = format!(
            "http://{}.{}.svc.cluster.local:{}/v1",
            garage.prefixed_name("api"),
            garage.namespace().unwrap(),
            admin_port,
        );

        Ok(GarageAdmin {
            garage,
            client: client::Client::new_with_client(&url, client),
        })
    }

    pub async fn layout_instance(&self, capacity: i64) -> Result<bool> {
        // Get the current status of the instance, failing if it is unhealthy
        let nodes = self.client.get_nodes().await?.into_inner();

        // If the node has been laid out already, then skip
        // TODO: Write out a message
        let node_id = nodes.node;
        if nodes.layout.version != 0 {
            return Ok(true);
        }

        // Add a layout request if we did not already
        let staged = nodes
            .layout
            .staged_role_changes
            .iter()
            .find(|change| match change {
                NodeRoleChange::Update(NodeRoleUpdate { id, .. }) => *id == node_id,
                _ => false,
            })
            .is_some();

        if !staged {
            let _layout = self
                .client
                .add_layout(&vec![NodeRoleChange::Update(NodeRoleUpdate {
                    capacity: Some(capacity),
                    id: node_id,
                    tags: vec![
                        "owned-by/garage-operator".into(),
                        format!("garage-instance/{}", self.garage.name_any()),
                    ],
                    zone: self.garage.spec.config.region.clone(),
                })])
                .await?;
        }

        // Actually apply the layout
        let _apply = self
            .client
            .apply_layout(&LayoutVersion { version: 1 })
            .await?;

        // TODO: Write out a message
        Ok(false)
    }
}
