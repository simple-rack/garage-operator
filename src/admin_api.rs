use std::time::Duration;

use kube::ResourceExt;
use reqwest::header::{HeaderMap, HeaderValue, AUTHORIZATION};

use crate::{resources::Garage, Result};

use self::client::types::{LayoutVersion, NodeRoleChange, NodeRoleUpdate};

/// Autogenerated client for the garage admin API using its corresponding openapi spec.
mod client {
    #![allow(dead_code)]
    include!(concat!(env!("OUT_DIR"), "/garage-admin-client.rs"));
}

pub struct GarageAdmin<'a> {
    garage: &'a Garage,
    client: client::Client,
}

impl<'a> GarageAdmin<'a> {
    pub fn with_secret(garage: &'a Garage, token: &str) -> Result<GarageAdmin<'a>> {
        // All requests must be authenticated using bearer auth
        let headers = {
            let mut headers = HeaderMap::new();
            let mut auth = HeaderValue::from_str(&format!("Bearer {token}")).unwrap();
            auth.set_sensitive(true);

            headers.insert(AUTHORIZATION, auth);
            headers
        };

        // Use a client to handle setting common request parameters
        // TODO: Handle error here nicely
        let client = reqwest::Client::builder()
            .connect_timeout(Duration::from_secs(5))
            .default_headers(headers)
            .build()
            .unwrap();

        let admin_port = garage.spec.config.ports.admin;
        let url = format!(
            "http://{}.{}.svc.cluster.local:{}/v1",
            garage.prefixed_name("api"),
            garage.namespace().unwrap(),
            admin_port,
        );

        Ok(GarageAdmin {
            garage,
            client: client::Client::new_with_client(&url, client),
        })
    }

    pub async fn layout_instance(&self, capacity: i64) -> Result<bool> {
        // Get the current status of the instance, failing if it is unhealthy
        let nodes = self.client.get_nodes().await?.into_inner();

        // If the node has been laid out already, then skip
        // TODO: Write out a message
        let node_id = nodes.node;
        if nodes.layout.version != 0 {
            return Ok(true);
        }

        // Add a layout request if we did not already
        let staged = nodes
            .layout
            .staged_role_changes
            .iter()
            .find(|change| match change {
                NodeRoleChange::Update(NodeRoleUpdate { id, .. }) => *id == node_id,
                _ => false,
            })
            .is_some();

        if !staged {
            let _layout = self
                .client
                .add_layout(&vec![NodeRoleChange::Update(NodeRoleUpdate {
                    capacity: Some(capacity),
                    id: node_id,
                    tags: vec![
                        "owned-by/garage-operator".into(),
                        format!("garage-instance/{}", self.garage.name_any()),
                    ],
                    zone: self.garage.spec.config.region.clone(),
                })])
                .await?;
        }

        // Actually apply the layout
        let _apply = self
            .client
            .apply_layout(&LayoutVersion { version: 1 })
            .await?;

        // TODO: Write out a message
        Ok(false)
    }
}
